# 프론트엔드 개발 공부 노트 - Web 기본 개념

## 프로그램이란?

프로그램은 컴퓨터에게 특정 작업을 수행하도록 지시하는 '코드 덩어리'! **명령어와 데이터의 집합**이다. 프로그래머로서 프로그램을 개발할 때 어떻게 메모리를 가장 효율적으로 사용하며 개발할 수 있을지를 고민해 봐야한다고 생각된다.

## 브라우저 주소창에 구글을 입력하면 어떤일이 일어날까?

브라우저 주소창에 도메인 이름을 입력하면 DNS(Domain Name System) 조회를 통해 해당 도메인의 IP 주소를 얻고, 받은 IP 주소를 사용하여 해당 서버에 연결한다. 브라우저는 HTTP 프로토콜을 사용하여 서버에 요청을 보내고 (일반적으로 GET 요청), 서버는 해당 요청에 대한 응답을 생성하여 브라우저에게 전달하고, 브라우저는 응답을 처리하여 사용자에게 웹 페이지를 표시한다.

<br> ❓그럼 **DNS**(Domain Name System)이란 무엇일까?<br>❗️DNS는 인터넷에서 도메인 이름과 IP 주소 간의 변환을 담당하는 시스템! DNS는 사용자가 이해하기 쉬운 도메인 이름 (예: www.google.com)을 컴퓨터가 이해할 수 있는 IP 주소로 매핑하는 역할을 한다.
<br>

## 브라우저 렌더링 원리

브라우저 렌더링이란 HTML,CSS, Javascript 등의 웹페이지 자원을 브라우저가 화면에 그리는 과정이다.
우선 브라우저는 HTML 문서를 파싱하여 **DOM트리를 생성**한다. 이때, HTML 태그를 노드로 변환하고, 노드간의 계층 관계를 형성한다.
두 번째로 CSS 파일을 파싱하여 **CSSOM을 생성**한다. 이때, CSS 속성을 노드로 변환하고, 노드간의 계층 관계를 형성한다.
세 번째로 DOM트리와 CSSOM을 결합하여 **렌더 트리를 생성**한다. 이때, 실제 화면에 표시될 요소만을 선택하여 렌더 트리를 형성한다.
이렇게 생성된 렌더 트리를 통해 브라우저는 각 요소의 크기와 위치를 계산하는 과정인 **레이아웃**을 거쳐 화면에 요소를 그리는 **페인팅** 과정을 거치는데, 이때, 요소의 배경, 테두리, 글자 등을 그려준다.

<br>❓DOM 트리는 문서의 요소(Element)들과 구조를 표현하는 트리 구조<br>❓CSSOM 트리는 문서의 요소들에 대한 스타일 정보를 포함<br>❓렌더 트리는 실제로 화면에 렌더링되는 요소들을 포함, 표시되지 않는 요소들(head, script)은 포함되지 않는다.
<br>

## 프론트엔드에서 '스켈레톤'이란?

스켈레톤: skeleton 자체의 의미는 **뼈대**! 프론트엔드에서는, 로딩 과정을 거치기 전 웹사이트의 뼈대를 나타낸다. 즉, 웹 페이지나 앱의 로딩 중에 사용자에게 빈 화면 대신 보여지는 시각적인 효과를 의미한다. 이렇게 그냥 빈 화면이 아닌 로딩 중이라는 **시각적인 효과** 를 주어 딜레이를 다루는 데에 동움이 되며, 사용자들이 페이지 내용이 로딩 중임을 인지하고 이를 기다리는 동안 불편함을 최소하하기 위한 효과적인 방법 중 하나다.

## HTTP와 HTTPS!

HTTP(Hypertext Transfer Protocol)와 HTTPS(Hypertext Transfer Protocol **Secure**)<br>
HTTP는 암호화되지 않은 프로토콜이며 보안이 취약한 반면, HTTPS는 데이터의 암호화와 웹 사이트의 신원 인증을 제공하여 보안성을 강화한다!

## REST API란 무엇일까?

서버 연동 작업을 할때 자주 보고 듣게 되는 REST API이지만 정확히 뭔지 정리해 보려고 한다!
우선 REST는 Representational State Transfer의 약자로, **표현 상태를 전송** 하는 웹 서비스와 클라이언트 간의 통신을 위한 아키텍처 스타일이다. REST API는 널리 사용되는 API 디자인 패턴 중 하나이며, HTTP 프로토콜을 기반으로 데이터를 전송하고, 서버의 리소스에 대한 CRUD(Create, Read, Update, Delete) 작업을 수행한다.
이 때, REST API는 일반적으로 HTTP 메소드(GET, POST, PUT, DELETE 등)를 사용하여 리소스에 대한 액션을 나타낸다.

- GET 메소드는 리소스를 조회하고 (Read)
- POST 메소드는 리소스를 생성하고 (Create)
- PUT 메소드는 리소스를 업데이트하고 (Update)
- DELETE 메소드는 리소스를 삭제하는 (Delete) 작업을 수행한다.
  <br>

## GET과 POST의 차이는?

[GET 메소드는 리소스를 조회하고 POST 메소드는 리소스를 생성]에서 알 수 있듯이, GET은 서버로부터 데이터를 받아오고, POST는 데이터를 서버로 보내준다.

**GET은** 요청 **URL에 파라미터를 통해 데이터를 전송**하고, **POST는** 요청 URL이 아닌 요청의 **본문(body)에 데이터를 포함하여 전송**한다.

이 과정에서 GET은 데이터가 URL에 노출되므로 보안과 데이터 길이 제한에 제약을 받을 수 있다. 반면에 POST는 데이터가 URL에 노출되지 않으므로, 보안적인 측면에서 GET보다 안전하며 데이터 길이에 제한이 없다.

## 객체지향 프로그래밍 (Object-Oriented Programming)이란 무엇일까?

객체지향 프로그래밍이란, 프로그래밍 할때 서로 밀접하게 연관되어 있는 요소들을 객체로 구성해 나가면서 객체끼리 서로 호환 가능하게 하는 것이다.<br>
객체지향 프로그램과 관련된 개념들<br>

- 클래스 (Class): 클래스는 객체를 생성하기 위한 템플릿이며, 객체의 구조와 행동을 정의하는데 사용된다. 클래스는 property(데이터)과 method(행동)로 구성된다.

- 객체 (Object): 클래스의 인스턴스로, 실제로 메모리에 할당된 개별적인 데이터를 나타낸다. 객체는 클래스에 정의된 property와 method를 사용할 수 있다.

- 캡슐화 (Encapsulation): 객체 내부에 있는 속성은 외부에서 직접 접근할 수 없으므로 이는 객체의 내부 구현을 외부로부터 감추고, 객체의 일관성과 보안성을 높여준다. **--> 정보은닉**<br>❓ 클래스도 데이터와 메서드를 묶는 것, 캡슐화도 데이터와 메서드를 묶는 것! 그럼 클래스와 캡슐화의 개념은 어떻게 다른걸까?<br>❗️ **캡슐화는** 데이터와 메서드를 하나의 단위로 묶는 **프로그래밍 개념**을 말하며, **클래스는** 객체를 생성하기 위한 템플릿 또는 설계도로서, **캡슐화를 실현하는데 사용될 수 있는 객체지향 프로그래밍의 구현 방법**! 클래스는 캡슐화를 통해 데이터와 해당 데이터를 조작하는 메서드를 하나의 단위로 묶을 수 있다.

- 상속 (Inheritance): 상속은 기존의 클래스로부터 새로운 클래스를 생성하는 개념이다. 상속을 통해 기존 클래스의 속성과 메소드를 재사용하고 확장할 수 있어 코드 재사용성과 유지보수성을 향상시킨다.

## 자료구조 stack과 queue의 차이는?

stack과 queue 모두 일렬로 정렬된 데이터를 다루는 자료구조이다. <br>우선 ❗️**스택은 프링글스통**을 떠올려보자! Last In First Out (LIFO)으로, 가장 최근에 추가된 데이터가 가장 먼제 삭제된다. push와 pop을 통해 요소를 추가/ 삭제하며, top은 스택의 맨 위에 있는 데이터를 반환한다.<br>❗️**큐는 줄서는 사람들**을 생각하면 이해가 쉽다! First In First Out (FIFO)으로 가장 오래된 데이터부터 삭제된다. enqueue와 dequeue를 통해 요소를 추가/ 삭제하며, front는 맨 앞에 있는 데이터를 반환한다.
<br>

## 프로세스와 스레드란?

**프로세스(Process)는 운영 체제에서 실행 중인 프로그램**으로, 프로그램에 필요한 코드, 데이터, 메모리 등의 자원과 실행 상태 정보를 가지고 있다. 운영 체제는 각각의 프로세스에 **독립적인 메모리 공간을 할당**하고, 프로세스들을 관리한다. 여러 개의 프로세스는 동시에 실행될 수 있고, 각각의 프로세스는 **서로 간에 독립된 실행 흐름**을 가지게 된다. 이를 통해 여러 프로그램을 동시에 실행하거나, 프로그램 간에 데이터를 공유하거나 통신할 수 있는 것이다!<br>
**스레드(Thread)는 프로세스 내에서 실행되는 작업의 단위**로, 프로세스는 하나 이상의 스레드를 가질 수 있으며, 각각의 스레드는 독립적으로 실행될 수 있다. 스레드는 ❗️**프로세스 내부에서 메모리와 자원을 공유하는 특징을 가져 여러 작업을 병렬로 처리하거나 동시에 실행**할 수 있어 프로그램의 성능을 향상시키는 데 활용된다. 하지만 동시에 실행되는 스레드가 동일한 자원에 접근하고 수정할 때 예기치 않은 결과가 발생할 수 있기 때문에 **스레드 간의 동기화와 데이터 공유에 주의**해야 한다!<br>

**🤓 요약**: 프로세스와 스레드는 프로그램 실행의 단위를 나타내는 개념으로, 프로세스는 독립된 실행 환경을 갖고 스레드는 프로세스 내에서 실행되는 작업의 단위이다.
<br>

## CSR 과 SSR : 렌더링 방식의 차이

❓ Client-Side-Rendering & Server-Side-Rendering, 각 각 클라이언트와 서버에서 렌더링을 한다는 특징을 지니고 있다. 이렇게 클라이언트와 서버에서 렌더링 할 경우 어떤 차이점이 발생하게 될까?

**초기 로딩 속도**

- CSR은 초기 페이지 요청 시에 빈 HTML을 받고, 이후에 데이터를 요청하여 동적으로 콘텐츠를 렌더링 한다. 이때, 필요한 컴포넌트만 리렌더링 되기 때문에 속도가 그 이후부터는 빨라진다.
- SSR은 초기 페이지 요청 시에 이미 완전한 HTML을 받기 때문에 초기 로딩 속도가 빠르다. 하지만 페이지를 이동할때마다 서버에 요청을 해야해서 초기에만 로딩 속도가 빠르다.

**검색 엔진 최적화(SEO)**

- CSR은 클라이언트 측에서 동적으로 콘텐츠를 생성하기 때문에 검색 엔진이 페이지의 콘텐츠를 크롤링하기 어렵다.
- SSR은 서버 측에서 렌더링되어 전달되는 HTML이 이미 포함된 상태이므로 검색 엔진 (웹 봇)이 HTML 태그들을 바탕으로 콘텐츠를 크롤링할 수 있다.

**사용자 경험**

- CSR은 초기 로딩 이후에는 업데이트가 필요한 부분만 업데이트 해주기 때문에 사용자 경험이 향상된다.
- SSR은 초기 로딩 속도는 빠르지만 업데이트가 필요할 때마다 서버 요청이 필요하므로 효율적이지 않다.
  <br>

## React는 CSR, 그럼 Next는?

Next.js는 CSR과 SSR을 모두 지원하기 때문에 필요에 따라 CSR과 SSR을 조합하여 사용할 수 있다! CSR의 단점을 보완해주며 SEO를 향상시켜주고, 동적인 기능을 사용할 수 있다.
<br>Next에서 **getStaticProps와 getServerSideProps**는 데이터를 가져오는 방법을 제공하는 함수다. Next.js의 서버 사이드 렌더링(SSR) 기능을 활용하여 페이지를 렌더링하기 전에 데이터를 미리 가져올 수 있게 해준다.

- getStaticProps는 사이트가 처음 빌드될 때에 딱 한번! 데이터를 불러오는 것이다. 주로 정적인 데이터가 자주 변경되지 않는 경우에 사용한다.
- getServerSideProps는 매 요청마다 데이터를 불러와 페이지를 렌더링한다. 동적인 컨텐츠가 자주 변경되는 경우에 사용한다. (수정사항 있으면 바로 업데이트 해주는 느낌)

내 경우에는, 포트폴리오 웹사이트를 제작하는 과정에서 Next.js를 이용하여 진행하였다. 이때, 포트폴리오 소개나 형식을 수정할 경우를 위해, 동적인 업데이트를 위해 getServerSideProps를 사용해 주었다.
<br>

## SPA와 MPA : 구조와 동작 방식의 차이

❓ Single Page Application & Multiple Page Application으로
단일 페이지의 HTML 페이지와 여러개의 독립적인 HTML 페이지로 구성된 웹 어플리케이션을 나타낸다. 이렇게 다른 구조의 웹 어플리케이션은 어떤 차이를 만들어낼까?

SPA는 하나의 HTML 페이지가 로드되고 이후에는 동적으로 데이터를 가져와서 해당 페이지 내에서 콘텐츠를 업데이트하여 사용자 경험에 효율적이고, MPA는 서버로부터 완전한 HTML을 받아와 렌더링되어 검색 엔진이 쉽게 콘텐츠를 크롤링하고 인덱싱할 수 있다.

## CORS (Cross-Origin Resource Sharing)란?

웹 브라우저에서 실행되는 JS 코드가 동일 출처가 아닌 다른 출처의 리소스에 접근할 수 있도록 허용하는 **보안 매커니즘**. 웹 애플리케이션은 원래 동일 출처 정책에 따라 다른 출처의 리소스에 직접 접근할 수 없다. 서버는 HTTP 응답 헤더인 **Access-Control-Allow-Origin**을 설정하여 특정 출처에서 오는 요청을 허용할 수 있다. 이를 통해 **클라이언트와 서버 간의 상호 작용을 확장**하고, **보안을 유지하면서 웹 애플리케이션의 기능을 향상**시킬 수 있다.

## 테스트 코드 작성의 중요성!

테스트 코드를 통해 **버그 발생률을 줄일 수 있다**. 각 기능에 대한 테스트 케이스를 만들어 해당 기능이 예상대로 작동하는지 확인하고, 변경 사항이 이전 기능에 영향을 미치지 않도록 한다! 즉, **유지보수도 효율적**으로 관리할 수 있는데, 변경 사항이 기존 기능을 해치지 않는지 테스트 코드를 통해 확인할 수 있다는 점이다.
<br>

## CI (Continuous Integration), CD (Continuous Deployment)란?

우리가 협업 프로젝트를 진행하며, 깃(Git) 레포지토리에 개발자들이 작성한 코드를 머지(Merge)하고 푸시(Push)하고 풀(Pull)을 받아, **지속적으로 통합**하며 작업을 하는 과정이 **CI**에 해당된다. 이렇게 작업을 하며 Vercel 또는 다른 배포 도구를 통해 사이트를 배포할 수 있는데, 이때 **지속적으로 배포**되도록 하는 과정은 **CD**에 해당된다!<br>
즉, CI/CD를 통해 개발자들이 코드를 통합하고 테스트, 배포하는 일련의 번거로운 과정을 자동화하여, 더욱 빠르게 안정적인 소프트웨어를 제공할 수 있다.
<br>

## MSA (Microservices Architecture) 란 뭘까?

소프트웨어 시스템을 **작은 독립적인 서비스들로 분할하는 소프트웨어 아키텍처 디자인 패턴**이다! 기존의 모놀리식(Monolithic) 아키텍처에서는 모든 기능과 로직이 하나의 큰 애플리케이션으로 통합되어 있었지만, MSA는 이를 작은 단위의 독립적인 서비스들로 나누어서 개발하고, 서비스들이 상호 독립적으로 배포, 운영, 확장될 수 있도록 한다. 이를 통해 새로운 기능을 추가하거나 기존 기능을 수정할 때, 해당 기능과 관련된 서비스들만 수정하면 된다. 다른 서비스들과의 결합도가 낮아져 **유지보수와 개선이 용이**한 것이다! MSA는 주로 **대규모 시스템에서 유용**하다.<br>
❓ 그럼 프론트엔드 개발에서 MSA를 적용하는 경우는 어떻게 되는걸까?<br>❗️ 웹 애플리케이션의 각 기능을 독립적인 **마이크로 프론트엔드**로 분할! 이를 Micro Frontends 라고도 부른다고 한다. 각 마이크로 프론트엔드는 자체적인 기술 스택과 독립적으로 개발, 배포되며, 독립적인 서비스처럼 동작하게 된다.<br>

예를 들어, 한 웹 애플리케이션에는 유저 관리, 상품 목록, 결제 기능 등 다양한 기능이 포함되어 있을 수 있는데, 이러한 기능들을 각각 독립적인 마이크로 프론트엔드로 분할하여 별도의 레포지토리로 관리되고, 개발팀이 독립적으로 담당한다.<br>

❓ 마이크로 프론트엔드의 장점은?<br>❗️ 큰 규모의 웹 애플리케이션을 여러 개발 팀이 협업하여 개발할 때 유용하게 사용될 수 있다. 리액트, 뷰, 앵글러를 제각각 사용하는 개발자들의 협력도 가능하며, 유연하고 확장성 있는 아키텍처를 제공할 수 있다!<br>**#독립적인 개발, #별도 배포, #기술 다양성, #성능과 확장성**
