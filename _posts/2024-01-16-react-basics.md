---
layout: post
title: "React 기초부터 실전까지 - 현대적인 프론트엔드 개발의 시작"
date: 2024-01-16
categories: react
tags: [React, 프론트엔드, 라이브러리, JavaScript]
---

# React 기초부터 실전까지 - 현대적인 프론트엔드 개발의 시작

React는 현재 가장 인기 있는 프론트엔드 라이브러리 중 하나입니다. 이번 포스트에서는 React의 기초 개념부터 실전 적용까지 알아보겠습니다.

## 프론트엔드 개발자로서 React를 사용하는 이유!

React는 Facebook에서 개발된 프론트엔드 라이브러리로, 대규모의 생태계를 가지고 있다. 커뮤니티가 크고 다양한 라이브러리, 도구가 있어서 개인적으로는 공부하며 학습해 나가기에는 React가 수월하다고 생각해서 Vue가 아닌 React로 진행하고 있다. React를 충분히 학습하고 익힌 이후에 Vue도 학습해보고 싶다!

## Virtual DOM은 무엇이며 작동 원리는?

가상 DOM은 메모리 내에서 가상으로 렌더링되는 가벼운 복사본으로서, 변경된 부분만 실제 DOM에 적용하여 UI를 업데이트 한다. 이를 통해 효율적인 UI 업데이트를 가능하게 하며 성능 향상과 빠른 렌더링이 가능해진다.

## state를 직접 변경하지 않고 useState 훅을 이용하는 이유는?

useState는 React의 **불변성** 원칙과 성능 최적화를 지원하며, 코드의 가독성과 **유지보수성**을 향상시킨다!

컴포넌트의 state는 불변성을 유지해야 React가 상태 변경을 감지하고 적절한 업데이트를 수행할 수 있는데, **상태를 직접 변경하면 React는 이전과 현재 상태의 차이를 판단하기 어려워지고, 업데이트를 제대로 수행할 수 없다.**

❓ 이유는? React는 가상 DOM을 사용하여 이전과 현재의 DOM 트리를 비교하여 변경 사항을 결정하는데, 상태를 직접 변경하면 React는 상태 업데이트를 추적하지 못하고, 가상 DOM 비교에 필요한 변경 사항을 정확히 파악할 수 없게 된다.

반면에, useState는 새로운 상태값과 해당 상태를 업데이트하는 함수를 제공하므로, 상태 변경이 어떻게 이루어지는지 명확하게 알 수 있고, 이를 통해 코드의 가독성과 유지보수성이 향상된다.

## 생명 주기 메서드

### 클래스형 컴포넌트에서 사용되는 주요 생명주기 메서드

- `componentDidMount()`: 컴포넌트가 최초로 DOM에 마운트된 직후에 호출
- `componentDidUpdate(prevProps, prevState)`: 컴포넌트가 업데이트되고 리렌더링된 후에 호출
- `componentWillUnmount()`: 컴포넌트가 언마운트되어 DOM에서 제거되기 전에 호출

### 함수형 컴포넌트에서 사용되는 주요한 생명주기 훅

- `useEffect()`: 컴포넌트가 마운트되거나 업데이트된 직후에 호출 (클래스형 컴포넌트의 componentDidMount + componentDidUpdate와 유사한 역할) - **비동기적**
- `useLayoutEffect()`: useEffect()와 유사하지만, 렌더링 이후 DOM 업데이트 전에 **동기적**으로 호출

## HOC (Higher-Order Component)?

React에서 사용되는 디자인 패턴 중 하나로, 함수형 프로그래밍의 개념을 활용하여 컴포넌트를 감싸고, 새로운 컴포넌트를 반환하는 함수이다!

❓ 언제 사용할까?
❗️ 컴포넌트간의 **로직을 재사용**하고, **공통 기능**을 구현하는 데 사용한다. 예를 들어, 여러 컴포넌트에서 동일한 인증 기능을 사용해야 한다면, HOC를 활용하여 인증 로직을 담당하는 HOC를 만들고 해당 로직을 재사용할 수 있다.

❓ 어떻게 사용할까?
❗️ 기존 컴포넌트를 매개변수로 받아 새로운 기능을 추가한 새로운 컴포넌트를 반환. HOC는 고차 함수(higher-order function)로서, **컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 함수**라고 생각하면 된다!

## package.json 에서 "dependencies" 와 "devDependencies"

```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },

  "devDependencies": {
    "eslint-config-react-app": "^7.0.1"
  }
}
```

React로 프로젝트 작업을 할 때, package.json 파일을 통해 프로젝트에 대한 정보와 의존성 패키지를 관리한다. 이때 "dependencies"와 "devDependencies"의 차이는 뭘까?

"dependencies"는 프로젝트를 배포할 때에도 함께 작동해야하는 의존성 패키지들의 묶음이고, "devDependencies"는 개발자가 프로젝트를 개발하고 테스트하는 동안 필요한 패키지들의 묶음이다. 즉 **"dependencies"는 프로덕션 환경에서 필요**한 패키지들을 나타내는 프로퍼티이며, **"devDependencies"는 개발 단계에서만 필요**한 패키지들을 나타내는 프로퍼티이다!

## 리액트에서 JSX 문법이 어떻게 사용될까?

JSX는 JavaScript 확장 문법으로 하나의 파일에서 자바스크립트와 html을 동시에 작성할 수 있다.

## Context API: 상태값을 전역적으로 관리해 줄때!

Context API는 React의 **상태 관리 패턴 중 하나로, 컴포넌트 트리 전체에서 데이터를 공유하기 위한 메커니즘을 제공**한다.

❓ 두 컴포넌트의 상태값을 공유해야 한다면?
❗️ state를 가장 근접한 부모 컴포넌트로 올린다! 그리고 자식 컴포넌트에게 props로 전달.

하지만 아래, 아래의 자식 컴포넌트에 계속해서 전달 (prop drilling)해야 한다면 모든 컴포넌트마다 props로 전달하게 되어 비효율적이게 된다! 따라서 이를 해결하기 위해 Context API를 사용해 어플리케이션 전반적으로 필요한 경우에 사용해준다. (언어, 다크모드, 로그인 여부 등)

## React Hook

React 함수형 컴포넌트에서 상태 관리와 다른 React 기능을 사용할 수 있게 해주는 기능으로, React Hook을 통해 함수형 컴포넌트에서도 상태를 관리하고 생명주기 메서드와 유사한 동작을 수행할 수 있게 되었다.

- `useState()`: useState()는 상태를 관리하기 위한 훅으로, 함수형 컴포넌트 내에서 상태 변수와 해당 상태를 업데이트하는 함수를 제공한다.
- `useEffect()`: useEffect()는 생명주기 메서드와 유사한 동작을 수행하는 훅으로, 컴포넌트가 마운트, 업데이트, 언마운트될 때 특정 동작을 수행할 수 있다.

## 클래스형 컴포넌트 vs. 함수형 컴포넌트

### 상태관리
클래스형 컴포넌트: this.state를 사용하여 상태(state)를 관리. setState() 메서드를 호출하여 상태를 업데이트하고, 생명주기 메서드를 사용하여 상태 변화에 따른 작업을 수행할 수 있다.

함수형 컴포넌트: useState() 훅을 사용하여 상태를 관리. useState()는 상태값과 해당 상태를 업데이트하는 함수를 반환한다.

### 컴포넌트 구성
클래스형 컴포넌트: 복잡한 컴포넌트 계층 구조에서는 컴포넌트 간의 계층 구조를 쉽게 구성. this.props를 통해 부모 컴포넌트로부터 전달된 속성값을 사용할 수 있다.

함수형 컴포넌트: 함수의 형태로 작성되기 때문에, 더 간단하고 읽기 쉬운 구조. 속성값은 함수의 인자로 전달되며, 부모 컴포넌트로부터 전달된 속성값을 사용할 수 있다.

**최근 리액트에서는 함수형 컴포넌트와 Hooks 사용을 권장하고 있다!**

## props와 state의 차이는?

**props는** 컴포넌트 간에 데이터를 전달하기 위한 메커니즘이고, 단방향으로 전달되어 자식 컴포넌트에서는 **읽기 전용**으로 사용된다! 반면에 **state는** 컴포넌트 내에서 **변경 가능**한 데이터를 관리하는 경우에 사용되며, 컴포넌트 내부에서 변경이 이루어지고 다시 렌더링되어 UI에 반영된다.

## Immer란 뭘까?

React Immer는 **불변성을 유지하면서 상태를 간편하게 업데이트**할 수 있도록 도와주는 라이브러리! React에서 상태를 업데이트할 때는 불변성을 유지하기 위해 새로운 객체를 생성하거나 배열을 복사하는 등의 작업을 해야하지만 Immer를 통해 번거로운 작업 없이 원본 상태를 직접 수정하는 것처럼 보이는 코드를 작성할 수 있다.

React의 기초 개념들을 정리해보았습니다. React는 계속 진화하는 라이브러리이므로, 최신 트렌드와 패턴들을 꾸준히 학습하는 것이 중요합니다! 🚀
