---
title: "브라우저는 어떻게 웹 페이지를 그릴까? - 렌더링과 스켈레톤"
date: "2023-09-02"
categories: ["frontend", "browser"]
tags: ["브라우저", "렌더링", "DOM", "CSSOM", "스켈레톤", "웹성능"]
excerpt: "브라우저 주소창부터 최종 렌더링까지의 과정을 이해하고, 사용자 경험을 향상시키는 스켈레톤 UI에 대해 알아봅니다."
---

# 🌐 브라우저 렌더링의 세계

안녕하세요! 오늘은 브라우저가 웹 페이지를 어떻게 화면에 표시하는지에 대해 깊이 있게 알아보겠습니다. 브라우저 주소창에 URL을 입력하는 순간부터 실제 화면에 픽셀이 그려지기까지의 과정을 단계별로 살펴보겠습니다.

## 🔍 브라우저 주소창에 URL을 입력하면?

브라우저 주소창에 도메인 이름(예: www.google.com)을 입력하면 다음과 같은 과정이 일어납니다:

### 1. DNS 조회
브라우저는 **DNS(Domain Name System)**를 통해 도메인 이름을 IP 주소로 변환합니다.

> **DNS란?** 인터넷에서 도메인 이름과 IP 주소 간의 변환을 담당하는 시스템입니다. 사람이 이해하기 쉬운 도메인 이름(`www.google.com`)을 컴퓨터가 이해할 수 있는 IP 주소(`142.250.206.100`)로 매핑하는 역할을 합니다.

### 2. 서버 연결 및 요청
- 변환된 IP 주소를 사용하여 해당 서버에 연결합니다
- **HTTP 프로토콜**을 사용하여 서버에 요청을 보냅니다 (일반적으로 GET 요청)
- 서버는 요청에 대한 응답을 생성하여 브라우저에게 전달합니다

### 3. 응답 처리 및 표시
브라우저는 서버로부터 받은 응답을 처리하여 사용자에게 웹 페이지를 표시합니다.

## 🎨 브라우저 렌더링 원리

브라우저 렌더링은 HTML, CSS, JavaScript 등의 웹페이지 자원을 브라우저가 화면에 그리는 복잡한 과정입니다.

### 1. DOM 트리 생성
브라우저는 HTML 문서를 파싱하여 **DOM(Document Object Model) 트리**를 생성합니다.

```html
<!DOCTYPE html>
<html>
  <head>
    <title>나의 웹페이지</title>
  </head>
  <body>
    <div class="container">
      <h1>안녕하세요!</h1>
      <p>웹 페이지 내용입니다.</p>
    </div>
  </body>
</html>
```

위 HTML은 다음과 같은 DOM 트리로 변환됩니다:
```
html
├── head
│   └── title
└── body
    └── div.container
        ├── h1
        └── p
```

### 2. CSSOM 생성
CSS 파일을 파싱하여 **CSSOM(CSS Object Model)**을 생성합니다.

```css
.container {
  width: 100%;
  padding: 20px;
}

h1 {
  color: blue;
  font-size: 24px;
}
```

CSSOM은 각 요소에 적용될 스타일 정보를 계층적으로 저장합니다.

### 3. 렌더 트리 생성
DOM 트리와 CSSOM을 결합하여 **렌더 트리**를 생성합니다.

> **렌더 트리**는 실제로 화면에 렌더링되는 요소들만을 포함합니다. `<head>`, `<script>` 등의 표시되지 않는 요소들은 제외됩니다.

### 4. 레이아웃 (Layout)
렌더 트리를 통해 각 요소의 크기와 위치를 계산합니다.

### 5. 페인팅 (Painting)
계산된 정보를 바탕으로 실제 픽셀을 화면에 그립니다.
- 요소의 배경, 테두리, 그림자
- 텍스트 렌더링
- 이미지 표시

## 💀 프론트엔드에서 '스켈레톤'이란?

프론트엔드 개발에서 **스켈레톤(Skeleton)**은 로딩 과정을 거치기 전 웹사이트의 뼈대를 의미합니다.

### 스켈레톤의 필요성

사용자가 웹 페이지를 방문할 때, 서버로부터 데이터를 받아와서 화면을 구성하는 동안 **빈 화면**이 표시되는 경우가 많습니다. 이는 사용자에게 다음과 같은 문제를 야기합니다:

- **불안감 유발**: 페이지가 로딩 중인지, 오류가 발생했는지 알 수 없음
- **이탈률 증가**: 사용자가 기다리지 않고 다른 페이지로 이동
- **사용자 경험 저하**: 전문적이지 않은 느낌

### 스켈레톤의 해결책

스켈레톤은 이러한 문제를 해결하기 위해 **로딩 중임을 시각적으로 표현**하는 방법입니다.

```html
<!-- 실제 콘텐츠 대신 표시 -->
<div class="skeleton">
  <div class="skeleton-header"></div>
  <div class="skeleton-content">
    <div class="skeleton-line"></div>
    <div class="skeleton-line"></div>
    <div class="skeleton-line"></div>
  </div>
</div>
```

```css
.skeleton {
  background: #f6f7f8;
  animation: loading 1.5s infinite;
}

.skeleton-line {
  height: 20px;
  background: #e0e0e0;
  margin-bottom: 10px;
  border-radius: 4px;
}

@keyframes loading {
  0% { opacity: 1; }
  50% { opacity: 0.4; }
  100% { opacity: 1; }
}
```

### 스켈레톤의 장점

1. **시각적 피드백**: 로딩 중임을 명확히 전달
2. **지루함 해소**: 빈 화면 대신 의미 있는 요소 표시
3. **인식된 성능 향상**: 실제 로딩 시간보다 빠르게 느껴짐
4. **브랜드 일관성**: 디자인 시스템 유지

## 🚀 성능 최적화 관점

렌더링 과정을 이해하면 다음과 같은 최적화 기회를 발견할 수 있습니다:

### 1. Critical Rendering Path 최적화
- HTML, CSS, JavaScript 로딩 순서 최적화
- 렌더링 차단 리소스 최소화

### 2. 스켈레톤 활용
- 초기 로딩 경험 개선
- Core Web Vitals 향상

### 3. 프로그레시브 로딩
- 중요 콘텐츠부터 순차적으로 표시
- 사용자 인식 성능 향상

## 💡 마무리하며

브라우저 렌더링은 단순히 화면을 그리는 것처럼 보이지만, 실제로는 복잡한 엔진과 알고리즘이 작동하는 정교한 과정입니다. 이러한 과정을 이해하면 더 나은 사용자 경험을 제공할 수 있습니다.

특히 스켈레톤 UI는 작은 디테일이지만, 사용자의 인식된 성능을 크게 향상시킬 수 있는 강력한 도구입니다.

다음 글에서는 HTTP와 HTTPS의 차이, 그리고 REST API에 대해 알아보겠습니다. 궁금한 점이 있으시면 댓글로 남겨주세요! 🌟
