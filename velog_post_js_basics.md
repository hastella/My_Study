# JavaScript 기초 개념 완벽 정리 - 프론트엔드 개발자를 위한 필수 지식

JavaScript는 프론트엔드 개발의 핵심 언어입니다. 이번 포스트에서는 JavaScript의 기초 개념들을 하나씩 살펴보겠습니다.

## 자바스크립트가 동적인 언어인 이유는?

우선 자바스크립트 언어는 몇가지 특징과 함께 동적인 프로그래밍 언어로 인식된다. 어떤 특징들이 자바스크립트 언어가 유동적인 언어라고 불리도록 한걸까?

- **동적 타입 시스템**: 변수의 타입을 선언하지 않고도 값에 따라 동적으로 타입이 결정된다.
- **동적 객체 모델**: 객체의 프로퍼티를 동적으로 추가, 삭제, 수정할 수 있다.
- **함수의 일급 객체**: 자바스크립트에서는 함수가 다른 값과 동일한 권한과 기능을 갖는 객체로 간주된다! 함수를 변수에 할당하거나, 다른 함수의 인자로 전달하고 반환 값으로 사용할 수 있다.
- **프로토타입 기반 상속**: 객체가 다른 객체를 상속받을 수 있다. 즉, 객체의 프로퍼티와 메서드를 동적으로 상속하고 재사용이 가능하다!

## 자바스크립트는 동기적으로 진행된다!

Javascript Runtime Environment, 하나의 싱글 컨텍스트 스택: 싱글 쓰레드 (Single Thread)

### 메모리 힙 & 콜스택 (동기성)

메모리 힙은 동적으로 할당되는 데이터 (객체, 배열 등)가 저장되는 공간이고, 콜 스택은 함수의 호출과 실행 순서를 기록하는 자료구조!

함수를 실행할 때 어떤 순서대로 동작해줄지는 Call Stack에 의해 결정된다. 따라서, **자바스크립트는 기본적으로 동기적으로 진행된다.** 하지만, 동기적으로 함수가 진행되는 경우에는, 만일 함수 하나의 실행 속도가 길어지는 경우 다른 함수의 실행에도 지장을 주게 되기 때문에, 비동기적인 작업을 처리해야 할 때는 비동기 API 함수들을 사용해주는 것이 좋다.

### 이벤트 루프 & 태스크 큐 (비동기성)

비동기처리 매커니즘에 관련된 개념으로, 이벤트 루프는 실행 중인 작업이 완료되면 테스크 큐에서 다음 작업을 가져와 실행하여 비동기 작업을 관리하고, 비동기 작업의 완료를 기다리는 동안에도 다른 작업을 처리할 수 있도록 도와준다!

## 애플리케이션 메모리 구조

어플리케이션을 실행시킬 때 필요한 메모리의 구성요소는 아래와 같이 나눠진다.

- **Code**: 개발자 작성 코드
- **Data**: 데이터, 변수
- **Stack**: 함수를 호출하는 실행순서
- **Heap**: 객체

## Variable 변수: 값을 저장하는 공간

어플리케이션을 실행하게 되면 총 세가지의 일들이 발생한다.

1. **입력 (input)**: 사용자에게 입력을 받는다. - 마우스 또는 키보드를 통해
2. **처리 (process)**: 필요한 데이터를 처리한다. - 파일을 통해
3. **출력 (output)**: 처리된 데이터를 출력한다.
   - 모니터를 통해 사용자에게 보여주거나
   - 파일 시스템, 쿠키, 스토리지 같은 곳에 저장하여
   - 네트워크 통신을 통해 다른 백엔드나 서버로 데이터를 보내주어

이 중, 처리 과정을 위해서는 데이터를 임시적으로 보관하기 위한 변수가 필요하다.
(= 사용자에게 입력받은 데이터를 보관하여 처리를 위한 데이터 보관, 변수 선언이 필요하다.)

## Data Type (데이터 타입)

- **원시 primitive (단일 데이터)**: number, string, boolean, null, undefined, symbol
- **객체 object (복합 데이터)**: 상태, 행동

이중 원시타입은 App의 구성요소중 Data와 Stack에 저장되고, 객체타입은 Heap에 저장된다.
Heap에는 데이터의 크기가 정해져있지 않고, 동적으로 데이터의 저장될 수 있는 '객체' 데이터가 보관된다.

## Object 객체: 연관된 데이터를 함께 묶어서 보관할 수 있는 복합 데이터

객체를 생성할 때는 중괄호나 생성자 함수를 통해 만들어줄 수 있다.

```javascript
const obj = {};
const obj = new Object();
```

**property**는 key와 value의 조합이다.
property 중 값을 함수로 가지는 것을 method라고 한다.

```javascript
person = {
  key: value, // property (프로퍼티 eg. 성별, 국적, 이름, 나이)
  speak() { // 함수를 value로, 메서드 이름인 speak()를 key값으로 가진다.
    console.log("hello")
  }
}
```

객체에 접근을 할때에는 점 또는 대괄호 표기법으로 접근할 수 있다.

```javascript
// 점 표기법
person.key, person.speak()

// 대괄호 표기법
person[key]
```

## 함수 (Function): 특정한 일을 수행하는 코드의 집합

함수의 장점:
- 👍🏻 **유지보수성**, **재사용 가능**, **높은 가독성**

❗️함수의 이름은 함수를 참조하고 있다. **(이름은 data/stack에 저장, 함수는 heap에 저장)**

### 매개변수 (Parameter) vs 인자 (Argument)

**인자를 받기 위해 함수 내부에서 생성한 변수를 매개변수** 라고 한다. 이 때, 인자는 함수를 호출할 때 넘겨주는 실제 값이고, 매개변수는 이 값을 받기 위해 함수 내부에서 만들어내는 변수를 말한다. 즉, **매개변수는** 함수 내부에서만 스코프를 유지하는 **지역변수**이다.

### 함수의 선언식과 표현식

**선언식**은 호이스팅에 의해 선언부가 먼저 처리되므로 (메모리에 먼저 저장되기 때문에) 어디에서든 호출할 수 있는 특징을 가진다. 즉, 자바스크립트 코드가 실행되기 전에 함수를 모두 정의해 두기 때문에 코드의 어디에서든 호출될 수 있다.

```javascript
functionName() // 함수 호출
function functionName(parameters) {
  // 함수 동작 내용
}
```

**표현식**은 변수에 함수를 할당하는 형태로 사용된다. 즉, 코드 실행 중에(런타임) 함수가 할당되기 때문에, 호이스팅되지 않는다. 때문에 변수에 할당되기 전에 호출하면 에러가 발생한다.

```javascript
functionName() // 에러 발생
var functionName = function(parameters) {
  // 함수 동작 내용
};
```

## 호이스팅 (Hoisting)

JS 엔진 (번역기, Interpreter)이 코드를 실행하기 전에 변수, 함수, 클래스의 선언문을 **끌어 올리는 것** (찾는다)을 말한다.

- **변수**의 선언만 코드의 최상단으로 옮겨 초기값은 할당되지 않고 undefined로 초기화된다. 초기화는 나중에 실행 단계에서 처리되기 때문에, 변수 선언부가 실행되기 전에 변수를 참조하면 undefined가 반환되어 에러가 발생하게 된다.

- **클래스**의 경우도 변수와 비슷한 동작을 수행하는데, 클래스 선언부가 호이스팅되어 메모리에 저장되지만, 클래스가 할당되는 부분은 따로 처리되지 않는다.

즉, 선언과 초기화를 분리한 후, **선언만 코드의 최상단**으로 옮긴다. 이 경우 할당된 값은 이후에 선언문을 만날때에 처리되기 때문에 선언문 이전에 호출하면 에러가 발생하게 된다.

```javascript
console.log(hi); // ReferenceError: Cannot access 'hi' before initialization
let hi = "hi";
```

## var의 단점은?

변수 선언하는 키워드가 없이 선언 & 할당이 가능해서 선언인지, 재할당인지 구분하기 어렵다.

```javascript
something = "something";
console.log(something);
```

중복 선언이 가능하다.

```javascript
var sangchu = "🐶";
var sangchu = "🐶🐶";
console.log(sangchu);
```

var과 다르게 let은 같은 변수명으로 재선언 할 경우 에러가 발생한다.

```javascript
let num = 0;
let num = 1;
console.log(num);
// SyntaxError: Identifier 'num' has already been declared
```

원래대로라면 블록 스코프 외부의 변수의 값을 호출해 주어야 하지만 var는 블록 스코프를 무시하고, 블록 스코프 내부의 변수의 값을 호출해 준다.

```javascript
var apple = "🍎";
{
  var apple = "사과";
}
console.log(apple); // 사과
```

의외로? 함수 레벨 스코프만 지원 된다.

```javascript
function example() {
  var sangchu = "🐶";
}
console.log(sangchu); // ReferenceError: sangchu is not defined
```

함수 내에서 선언된 var를 외부에서 호출 시도할 경우 ReferenceError가 발생한다.

## var, let, const의 차이는?

**var**은 앞 주제 var의 단점에서 다루었듯이, 변수의 **재선언과 재할당이 가능**하다. 때문에 선언인지, 재할당인지 구분이 어렵다. 이러한 단점을 보완하기 위해 ES6에서 도입된 let과 const가 있는데 이 두 선언 방식은 var과 어떻게 다른걸까?

**let**은 블록 스코프를 가지는 변수 선언 방식이다. 즉, 중괄호 {}로 둘러싸인 블록 내에서만 접근이 가능하다. 따라서 호이스팅은 발생하지만 선언 이전에 변수에 접근하면 ReferenceError가 발생한다. **변수의 재할당은 가능하지만 var과 다르게 재선언은 허용되지 않는다.**

**const** 또한 let과 함께 ES6에 도입된 상수를 선언하는 방식이다. let과 동일한 블록 스코프를 가지며, 중괄호{} 안에서만 접근이 가능하다. 상수이기에 **재할당이 불가하고, 선언과 동시에 초기화 해야 한다.**

## ==과 ===의 차이는?

**== 는 값의 동등성**을 비교할 때 타입 변환을 수행하고, **=== 는 값과 타입의 일치성**을 엄격히 비교한다. 타입 변환으로 인한 예상치 못한 결과를 피하기 위해서는 일치 연산자인 ===를 사용하는 것이 권장된다!

## Class 클래스: 객체를 생성할 수 있는 템플릿 (틀)

- **객체지향 프로그래밍 (Object - oriented Programming)**: 프로그래밍 할때, 서로 밀접하게 연관되어 있는 요소들을 객체로 구성해 나가면서 객체끼리 서로 호환 가능하게 하는 것.

- **인스턴스 (instance)**: 클래스를 통해 만들어진 객체

JavaScript의 기초 개념들을 정리해보았습니다. 다음 포스트에서는 JavaScript의 고급 개념들과 실제 활용 방법에 대해 알아보겠습니다! 🚀
